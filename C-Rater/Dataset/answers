1.1 To simulate<RL> the behaviour<RL> of portions<RL> of the desired software<RL> product. <STOP>
1.1 The main role of a prototype program in problem solving is to simulate<RL> the behaviour<RL> of portions<RL> of the desired software<RL> product. <STOP>
1.1 The role of a prototype program is to simulate<RL> the behaviour<RL> of portions<RL> of the desired software<RL> product. <STOP>
1.1 A prototype program simulates<RL> the behaviour<RL> of portions<RL> of the desired software<RL> product. <STOP>
1.1 The behaviour<RL> of portions<RL> of the desired software<RL> product are simulated<RL> by a prototype program in problem solving. <STOP>
1.1 The behaviour<RL> of portions<RL> of the desired software<RL> product are simulated<RL> by a prototype program. <STOP>
1.1 In problem solving, a prototype program simulates<RL> the behaviour<RL> of the portions<RL> of the desired software<RL> program. <STOP>
1.1 In problem solving, the behaviour<RL> of portions<RL> of the desired software<RL> product are simulated<RL> by a prototype program. <STOP>
1.1 In problem solving, the role of a prototype program is to simulate<RL> the behaviour<RL> of portions<RL> of the desired software<RL> product. <STOP>
1.2 The testing stage can influence both the coding<RL> stage -LRB- phase 5<RL> -RRB- and the solution<RL> refinement<RL> stage -LRB- phase 7<RL> -RRB- <STOP>
1.2 Phase 5<RL> and phase 7<RL> are influenced by the testing stage. <STOP>
1.2 Phase 7<RL> and phase 5<RL> are influenced by the testing stage. <STOP>
1.2 The coding<RL> stage and the solution<RL> refinement<RL> stage are influenced by the testing stage. <STOP>
1.2 Phase 5<RL> and 7<RL> of the software life cycle are influenced by the testing phase. <STOP>
1.2 The coding<RL> and solution<RL> refinement<RL> stages are influenced by the testing stage. <STOP>
1.2 The coding<RL> and solution<RL> refinement<RL> stages of the software life cycle are influenced by the testing stage. <STOP>
1.2 Phase 5<RL> and 7<RL> of the software life cycle are influenced by the testing stage. <STOP>
1.2 The testing phase influences the phase 5<RL> and phase 7<RL> of the software cycle. <STOP>
1.2 The testing phase influences the coding<RL> phase and the solution<RL> refinement<RL> phases of the software life cycle. <STOP>
1.2 The testing phase influences the coding<RL> phase -LRB- phase 5<RL> -RRB- and the solution<RL> refinement<RL> phase -LRB- phase 7<RL> -RRB- of the software life cycle. <STOP>
1.2 Phase 5<RL> and 7<RL>. <STOP>
1.2 The coding<RL> and solution<RL> refinement<RL> phase. <STOP>
1.3 Abstraction<RL> and reusability<RL>. <STOP>
1.3 The main advantages associated with object-oriented programming are abstraction<RL> and reusability<RL>. <STOP>
1.3 Abstraction<RL> and reusability<RL> are the main advantages associated with object-oriented programming. <STOP>
1.3 The advantages are abstraction<RL> and reusability<RL>. <STOP>
1.3 Abstraction<RL> and reusability<RL> are the advantages. <STOP>
1.3 Abstraction<RL> and reusability<RL> are the main advantages with object-oriented programming. <STOP>
1.4 At the main<RL> function<RL>. <STOP>
1.4 The C++ programs begin to execute at the main<RL> function<RL>. <STOP>
1.4 Main<RL> function<RL>. <STOP>
1.4 The C plus plus programs begin to execute at the main<RL> function<RL>. <STOP>
1.4 The main<RL> function<RL> begins the execution of the C++ program. <STOP>
1.4 The main<RL> function<RL> begins the execution of the C plus plus program. <STOP>
1.4 C++ program's execution is began at the main<RL> function<RL>. <STOP>
1.4 C plus plus program's execution is began at the main<RL> function<RL>. <STOP>
1.5 A location<RL> in memory<RL> that can store<RL> a value<RL>. <STOP>
1.5 A variable is a loction<RL> in memory<RL> that can store<RL> a value<RL>. <STOP>
1.5 A variable is a location<RL> in memory<RL>. <STOP> And it can store<RL> a value<RL>. <STOP>
1.5 A variable is stores<RL> a value<RL> which is a location<RL> in memory<RL>. <STOP>
1.5 A variable can store<RL> a value<RL>. <STOP> And it is a loction<RL> in memory<RL>. <STOP>
1.5 Can store<RL> a value<RL> which is a loction<RL> in memory<RL>. <STOP>
1.6 Variables can be declared anywhere in a program. <STOP> They can be declared inside<RL> a function<RL> -LRB- local<RL> variables -RRB- or outside<RL> the function<RL> -LRB- global<RL> variables -RRB- <STOP>
1.6 Variables can be declared inside<RL> a function<RL> or outside<RL> a function<RL>. <STOP>
1.6 Variables can be declared inside<RL> a function<RL> or outside<RL> a function<RL> in a c plus plus program. <STOP>
1.6 Variables can be declared inside<RL> a function<RL> or outside<RL> a function<RL> in a C++ program. <STOP>
1.6 Inside<RL> a function<RL> or outside<RL> a function<RL>. <STOP>
1.6 Outside<RL> a function<RL> or inside<RL> of a function<RL>. <STOP>
1.6 Inside<RL> a function<RL> -LRB- local<RL> variables -RRB- or outside<RL> a function<RL> -LRB- global<RL> variables -RRB-. <STOP>
1.6 Variables can be declared anywhere, inside<RL> or ouside<RL> of a function<RL>. <STOP>
1.6 Variables are of two types in C++, local<RL> variables which are declared inside<RL> of a function or global<RL> variables which are declared outside<RL> of a function. <STOP>
1.6 Variables are of two types in C plus plus, local<RL> variables which are declared inside<RL> of a function or global<RL> variables which are declared outside<RL> of a function. <STOP>
1.6 Variables are declared either inside<RL> or outside<RL> of a function<RL> in C++. <STOP>
1.6 Variables are declared either inside<RL> or outside<RL> of a function<RL> in C plus plus. <STOP>
1.7 The block inside a do<RL> ... while<RL> statement will execute<RL> at least once<RL>. <STOP>
1.7 The block inside a while<RL> loop may/may not<RL> execute<RL> depending on the condition. <STOP> But the block inside a do<RL> ... while<RL> loop will execute<RL> at least once<RL>. <STOP>
1.7 The main difference is, the do<RL> ... while<RL> loop will have at least one<RL> iterations<RL> but the while<RL> loop may have zero<RL> iterations<RL>. <STOP>
1.7 The main difference is, the do-while<RL> loop will be executed<RL> at least once<RL>, which is not<RL> true for a while<RL> loop. <STOP>
1.7 The do-while<RL> loop will be executed<RL> at least once<RL>, which is not<RL> true for a while<RL> loop. <STOP>
1.7 The while loop may not<RL> execute<RL> depending on the while<RL> condition, but a do-while<RL> loop will execute<RL> at least once<RL>. <STOP>
1.7 The while loop may not<RL> execute<RL> even once<RL>, but it's not<RL> true<RL> for a do-while<RL> loop. <STOP> A do-while<RL> loop will execute<RL> at least once<RL>. <STOP>
2.1 Data<RL> members<RL> -LRB- attributes<RL> -RRB- and member functions<RL> . <STOP>
2.1 A class definition includes Data<RL> members<RL> and member functions<RL> . <STOP>
2.1 A class definition includes attributes<RL> and member<RL> functions<RL> . <STOP>
2.1 Data<RL> members<RL> and member functions<RL> are included in a class definition. <STOP>
2.2 Data members can be accessed from any<RL> member<RL> functions<RL> inside the class defintion. <STOP> Local variables can only be accessed inside<RL> the member function that defines them. <STOP>
2.2 Local variables can only be accessed inside<RL> the member function that defines them. <STOP> Data members can be accessed from any<RL> member<RL> functions<RL> inside the class defintion. <STOP>
2.2 Data members can be accessed from any<RL> member<RL> functions<RL> inside the class defintion. <STOP> Local variables can only be accessed inside<RL> the member function that defines them. <STOP>
2.2 Local variables can only be accessed inside<RL> the member function that defines them. <STOP> Data members can be accessed from any<RL> member<RL> functions<RL> inside the class defintion. <STOP>
2.3 A constructor is called whenever an object<RL> is created, whereas a function needs to be called explicitely<RL> . <STOP> Constructors do not<RL> have return<RL> type<RL> , but functions have to indicate a return type. <STOP>
2.3 Constructors do not<RL> have return<RL> type<RL> , but functions have to indicate a return type. <STOP> A constructor is called whenever an object<RL> is created, whereas a function needs to be called explicitely<RL> . <STOP>
2.3 A constructor is called whenever an object<RL> is created, whereas a function needs to be called explicitely<RL> . <STOP> Constructors do not<RL> have return<RL> type<RL> , but functions have to indicate a return type. <STOP>
2.3 Constructors do not<RL> have return<RL> type<RL> , but functions have to indicate a return type. <STOP> A constructor is called whenever an object<RL> is created, whereas a function needs to be called explicitely<RL> . <STOP>
2.4 If no constructor is provided, the compiler<RL> provides one by default. <STOP> If a constructor is defined<RL> for a class, the compiler does not create a default constructor. <STOP>
2.4 If a constructor is defined<RL> for a class, the compiler does not create a default constructor. <STOP> If no constructor is provided, the compiler<RL> provides one by default. <STOP>
2.4 If no constructor is provided, the compiler<RL> provides one by default. <STOP> If a constructor is defined<RL> for a class, the compiler does not create a default constructor. <STOP>2.5 Unlimited number. <STOP>
2.4 If a constructor is defined<RL> for a class, the compiler does not create a default constructor. <STOP> If no constructor is provided, the compiler<RL> provides one by default. <STOP>
2.5 Unlimited<RL> number. <STOP>
2.5 Unlimited<RL> <STOP>
2.6 A function prototype includes the function<RL> signature<RL> , i. e., the name of the function, the return<RL> type<RL> , and the parameters<RL> 's type. <STOP> The function definition includes the actual body<RL> of the function. <STOP>
2.6 The function definition includes the actual body<RL> of the function. <STOP> A function prototype includes the function<RL> signature<RL> , i. e., the name of the function, the return<RL> type<RL> , and the parameters<RL> 's type. <STOP>
2.7 To store<RL> a class<RL> interface<RL> , including data<RL> members<RL> and member function<RL> prototypes<RL> . <STOP>
2.7 It stores<RL> a class<RL> interface<RL> , including member function<RL> prototypes<RL> and data<RL> members<RL> . <STOP>
3.1 The name<RL> of the function and the types<RL> of the parameters<RL> . <STOP>
3.1 Type<RL> of parameters<RL> and name<RL> of the function . <STOP>
3.2 File<RL> scope<RL> . <STOP>
3.2 Scope<RL> of the file<RL> . <STOP>
3.3 It makes a copy<RL> of the function<RL> code<RL> in every place where a function call is made. <STOP>
3.3 Copies<RL> function<RL> code<RL> . <STOP>
3.4 It avoids<RL> making copies<RL> of large<RL> data<RL> structures<RL> when calling functions. <STOP>
3.4 Doesn't<RL> make<RL> copies<RL> of lasrge<RL> data<RL> structures<RL> <STOP>
3.5 Based on the function<RL> signature<RL> . <STOP> When an overloaded function is called, the compiler will find the function whose signature<RL> is closest<RL> to the given function call. <STOP>
3.5 When an overloaded function is called, the compiler will find the function whose signature<RL> is closest<RL> to the given function call. <STOP>
3.6 If the recursion<RL> step is defined incorrectly<RL>, or if the base<RL> case<RL> is not<RL> included<RL> . <STOP>
3.6 When the recursion<RL> step is defined incorrectly<RL> , or when the base<RL> case<RL> is not includedRL> . <STOP>
3.7 They both involve repetition<RL> ; they both have termination<RL> tests<RL> ; they can both occur<RL> infinitely<RL> . <STOP>
3.7 They both involve repetition<RL> ; they can both occur<RL> infinitely<RL> ; they both have termination<RL> tests<RL> . <STOP>
4.1 In the array declaration<RL> , or by using<RL> an initializer<RL> list. <STOP>
4.1 By using<RL> an initializer<RL> list, or in the array<RL> declaration<RL> . <STOP>
4.2 The strings declared using an array of characters have a null<RL> element<RL> added at the end<RL> of the array. <STOP>
4.2 Have a null<RL> element<RL> added at the end<RL> of the array. <STOP>
4.3 by reference<RL> . <STOP>
4.3 By location<RL> <STOP>
4.4 The arrays declared as static live throughout the life of the program; that is, they are initialized<RL> only once<RL> , when the function that declares the array it is first called. <STOP>
4.4 They are initialized<RL> only once<RL> <STOP>
4.5 All<RL> the dimensions, except<RL> the first<RL> one<RL> . <STOP>
4.5 All<RL> the dimensions, minus<RL> the first<RL> one<RL>
4.6 Run-time<RL> error. <STOP>
4.6 Execution<RL> error <STOP>
4.7 By rows<RL> . <STOP>
4.7 By tuples<RL> <STOP>
5.1 Taking one array element at a time, from<RL> left to<RL> right, it inserts it in the right<RL> position among the already sorted<RL> elements on its left<RL>. <STOP>
5.1 From<RL> left<RL> to<RL> right<RL> <STOP>
5.2 Taking one array element at a time, from left to right, it identifies the minimum<RL> from the remaining elements and swaps<RL> it with the current element. <STOP>
5.2 It identifies the minimum<RL> from the remaining elements and swaps<RL> it with the current element. <STOP>
5.3 N<RL> -LRB- the length<RL> of the array -RRB- operations achieved for a sorted array. <STOP>
5.3 N<RL> <STOP>
5.4 When the size<RL> of the array to be sorted is 1<RL> -LRB- or 2<RL> -RRB- <STOP>
5.4 When size<RL> is 1<RL> or 2<RL> <STOP>
6.1 A variable<RL> that contains the address<RL> in memory<RL> of another variable. <STOP>
6.1 Contains address of another variable<RL> . <STOP>
6.2 The memory<RL> address<RL> of its operand<RL> . <STOP>
6.2 Mmory location<RL> of its operand<RL> <STOP>
6.3 An alias<RL> -LRB- synonym -RRB- for the name of the object that its operand points to in memory. <STOP> It is the dereferencing<RL> operator<RL> . <STOP>
6.3 It is the dereferencing<RL> operator<RL> . <STOP>
6.4 By initializing<RL> a pointer<RL> to point to the first element of the array, and then incrementing<RL> this pointer with the index of the array element. <STOP>
6.4 Bu initializing<RL> and incrementing<RL> the pointer <STOP>
6.5 The size<RL> in bytes of its operand. <STOP>
6.5 Size<RL> <STOP>
6.6 There are four ways: nonconstant<RL> pointer to constant<RL> data, nonconstant pointer to nonconstant data, constant pointer to constant data, constant pointer to nonconstant data. <STOP>
6.6 There are 4 ways: nonconstant<RL> pointer to constant<RL> data, nonconstant pointer to nonconstant data, constant pointer to constant data, constant pointer to nonconstant data. <STOP>
6.7 The address<RL> of the location<RL> in memory where the function code<RL> resides. <STOP>
6.7 The address<RL> of the location<RL> in memory where the function code<RL> resides. <STOP>
7.1 A collection<RL> of elements<RL> that can be allocated dynamically. <STOP>
7.1 A collection<RL> of elements<RL> . <STOP>
7.2 The linked lists can be of variable<RL> length<RL> . <STOP>
7.2 variable<RL> length<RL> <STOP>
7.3 The elements in an array can be accessed directly<RL> -LRB- as opposed<RL> to linked<RL> lists<RL> , which require iterative traversal -RRB- . <STOP>
7.3 The elements in an array can be accessed directly<RL>
7.4 By reference<RL> . <STOP>
7.4 By address<RL> <STOP>
7.5 The last<RL> element in a circular linked list points<RL> to the head<RL> of the list. <STOP>
7.5 The last<RL> element points<RL> to the head<RL> of the list. <STOP>
7.6 All<RL> the deletion and insertion operations can be performed in constant<RL> time, including those operations performed before a given location in the list or at the end of the list. <STOP>
7.6 All<RL> the deletion and insertion operations can be performed in constant<RL> time. <STOP>
7.7 Extra<RL> space<RL> required to store the back pointers. <STOP>
7.7 Extra<RL> space<RL> required <STOP>
8.1 A data structure that can store elements<RL> , which has the property that the last item added will be the first to be removed -LRB- or last-in-first-out -RRB- <STOP>
8.1 A data structure that can store elements<RL> <STOP>
8.2 push<RL> and pop<RL> <STOP>
8.2 push<RL> and pop<RL> operations <STOP>
8.3 Keep the top<RL> of the stack<RL> toward the end of the array, so the push and pop operations will add or remove elements from the right side of the array. <STOP>
8.3 Keep the top<RL> of the stack<RL> toward the end of the array. <STOP>
8.4 Keep the top<RL> of the stack<RL> pointing to the head<RL> of the linked list, so the push and pop operations will add or remove elements at the beginning of the list. <STOP>
8.4 Keep the top<RL> of the stack<RL> pointing to the head<RL> of the linked list <STOP>
8.5 Link-based<RL> , because they are dynamic<RL> -LRB- no size constraints -RRB- <STOP>
8.5 Link-based<RL> , because they are dynamic<RL> <STOP>
8.6 First, they are converted<RL> into postfix<RL> form, followed by an evaluation<RL> of the postfix<RL> expression. <STOP>
8.6 They are converted<RL> into postfix<RL> form, followed by an evaluation<RL> of the postfix<RL> expression. <STOP>
8.7 Pop<RL> all<RL> the elements and store<RL> them on another stack<RL> until the element is found, then push back all the elements on the original stack. <STOP>
8.7 Pop<RL> all<RL> the elements and store<RL> them on another stack<RL> until the element is found, then push back all the elements on the original stack. <STOP>
9.1 A data structure that can store<RL> elements<RL> , which has the property that the last item added will be the last to be removed -LRB- or first-in-first-out -RRB- . <STOP>
9.1 A data structure that can store<RL> elements<RL> <STOP>
9.2 enqueue<RL> and dequeue<RL> <STOP>
9.3 Use a circular<RL> array<RL> . <STOP> Keep the rear of the queue toward the end of the array, and the front toward the beginning, and allow the rear pointer to wrap around. <STOP>
9.3 circular<RL> array<RL>
9.4 Keep<RL> the rear<RL> of the queue<RL> pointing<RL> to the tail<RL> of the linked list, so the enqueue operation is done at the end of the list, and keep the front of the queue pointing to the head of the linked list, so the dequeue operation is done at the beginning of the list. <STOP>
9.4 Keep<RL> the rear<RL> of the queue<RL> pointing<RL> to the tail<RL> of the linked list <STOP>
9.5 Link-based<RL> , because they are dynamic -LRB- no size constraints -RRB- <STOP>
9.5 Link-based<RL> <STOP>
9.6 push<RL> <STOP>
9.7 queue<RL> <STOP>
10.1 A collection<RL> of nodes<RL>, which has a special node called root, and the rest of the nodes are partitioned into one or more disjoint sets, each set being a tree. <STOP>
10.1 collection<RL> of nodes<RL> <STOP>
10.2 The length<RL> of the longest<RL> path<RL> from the root to any of its leaves. <STOP>
10.2 Length<RL> of the longest<RL> path<RL>
10.3 A node that has no<RL> children<RL> . <STOP>
10.3 No<RL> subtrees<RL> <STOP>
10.4 A tree for which the maximum<RL> number of children<RL> per node is two<RL> . <STOP>
10.4 Maximum<RL> number of children<RL> per node is two<RL> . <STOP>
10.5 A binary<RL> tree that has the property that for any node the left child is smaller than the parent which in turn is smaller than the right child. <STOP>
10.5 A binary<RL> tree that has the property<RL> that for any node the left child is smaller than the parent which in turn is smaller than the right child. <STOP>
10.6 Traverse the left<RL> subtree, then the root<RL> , then the right<RL> subtree. <STOP>
10.6 Left<RL> , root<RL> , right<RL> <STOP>
10.7 The height<RL> of the tree<RL> -LRB- or log of the number of elements in the tree -RRB- . <STOP>
10.7 Log<RL> of the number<RL> of elements<RL> in the tree <STOP>
11.1 Function<RL> members and data<RL> members<RL> . <STOP>
11.1 Data<RL> members<RL> and function<RL> members <STOP>
11.2 Private<RL> and public<RL> . <STOP>
11.3 By using constructors<RL> . <STOP>
11.4 The name<RL> of the function<RL> and the list<RL> of parameters<RL>, including their types. <STOP>
11.4 The name<RL> of the function<RL> and the list<RL> of parameters<RL> <STOP>
11.5 A function that calls<RL> itself<RL> . <STOP>
11.5 calls<RL> itself<RL> . <STOP>
11.6 Through iteration<RL> . <STOP>
11.7 The static arrays are intialized<RL> only once<RL> when the function is called. <STOP>
11.7 Intialized<RL> only once<RL> when the function is called. <STOP>
11.8 The char []<RL> will automatically<RL> add<RL> a null<RL> 0 character at the end<RL> of the string. <STOP>
11.9 Divide<RL> a problem into smaller<RL> subproblems<RL> , solve them recursively, and then combine the solutions into a solution for the original problem. <STOP>
11.9 Divide<RL> a problem into smaller<RL> subproblems<RL> <STOP>
11.10 It splits<RL> the original<RL> array into two<RL> , sorts each of the two halves, and then merges the sorted arrays. <STOP>
11.10 It splits<RL> the original<RL> array into two<RL> <STOP>
12.1 The address of a location<RL> in memory<RL> . <STOP>
12.1 Memory<RL> location<RL> <STOP>
12.2 Implement<RL> the algorithm<RL> and measure<RL> the physical running<RL> time<RL> . <STOP>
12.2 Implement<RL> and measure<RL> running<RL> time<RL> of the algorithm<RL> . <STOP>
12.3 log<RL> -LRB- log<RL> n<RL> -RRB- ; 2 to the power of -LRB- log n -RRB- ; n to the power of 2; n to the power of 3; n! <STOP>
12.4 It selects<RL> the minimum<RL> from an array and places it on the first position, then it selects the minimum from the rest of the array and places it on the second position, and so forth. <STOP>
12.5 Linked lists are dynamic structures, which allow for a variable number of elements to be stored. <STOP>
12.6 A data structure that stores<RL> elements<RL> following the first<RL> in<RL> first out<RL> principle. <STOP> The main operations in a queue are enqueue and dequeue. <STOP>
12.6 A data structure that stores<RL> elements<RL> following the first<RL> in<RL> first out<RL> principle. <STOP>
12.7 push<RL> and pop<RL> <STOP>
12.8 A walk<RL> around<RL> the tree<RL> , starting with the root, where each node is seen three times: from the left, from below, from the right. <STOP>
12.8 A walk<RL> around<RL> the tree<RL> <STOP>
12.9 Find<RL> the node<RL>, then replace<RL> it with the leftmost<RL> node from its right<RL> subtree -LRB- or the rightmost<RL> node from its left<RL> subtree -RRB- . <STOP>
12.9 Find<RL> the node<RL>, then replace<RL> it with the rightmost<RL> node from its left<RL> subtree <STOP>
12.10 The height<RL> of the tree<RL> . <STOP>